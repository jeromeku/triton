from collections import defaultdict
from pathlib import Path
from typing import Dict, List, Optional, Sequence, Union

from dataclasses import dataclass

from triton.tools.aot.codegen import HeaderGenerator, HeaderParser, KernelLinkerMeta


class Linker:
    """
    Generates dispatcher code for from compiled triton kernels
    """

    HEADER_TEMPLATE = """
#include <cuda.h>
{algo_decls}
{get_num_algos_decl}
{global_decl}
"""

    def __init__(
        self,
        headers: List[str],
        out_path: Path,
        header_parser=HeaderParser,
        header_generator=HeaderGenerator,
        prefix: Optional[str] = "",
    ):
        """
        Args
            headers: Paths to header files to link. **Must** include linker directive annotations (autogenerated by ttc)

        """
        self.headers = headers
        self.out_path = out_path if isinstance(out_path, Path) else Path(out_path)
        self.prefix = prefix
        self.header_parser = header_parser()
        self.header_generator = header_generator

    def run(self):
        kernels = self.parse_headers()
        meta = self.generate_headers(kernels)
        self.generate_sources(meta)

    def parse_headers(self):
        for header in self.headers:
            h_path = Path(header)
            h_str = h_path.read_text()
            self.header_parser.extract_linker_meta(h_str)

        return self.header_parser.kernels

    def generate_headers(
        self, kernels: Dict[str, KernelLinkerMeta]
    ) -> KernelLinkerMeta:
        algo_decls = [
            self.header_generator.make_algo_decls(name, meta)
            for name, meta in kernels.items()
        ]
        algo_decl_str = "\n".join(algo_decls)

        meta_lists = [meta for _, meta in kernels.items()]
        meta = meta_lists[0][0]

        get_num_algos_decl_str = self.header_generator.make_get_num_algos_decl(meta)
        global_decl_str = self.header_generator.make_global_decl(meta)

        generated_header = self.HEADER_TEMPLATE.format(
            algo_decls=algo_decl_str,
            get_num_algos_decl=get_num_algos_decl_str,
            global_decl=global_decl_str,
        ).strip()

        output_file = self.out_path.with_suffix(".h")
        with output_file.open("w") as fp:
            fp.write(generated_header)

        return output_file, meta

    def generate_sources(
        self, meta: KernelLinkerMeta, kernels: Dict[str, KernelLinkerMeta]
    ):
        pass
        # defs = [
        #     make_kernel_hints_dispatcher(name, meta) for name, meta in kernels.items()
        # ]

        # names = [name for name in kernels.keys()]
        # func_pointers_def = make_func_pointers(names, meta)
        # meta_const_def = make_kernel_meta_const_dispatcher(meta)
        # load_unload_def = make_kernel_load_def(names, meta)
        # get_num_algos_def = make_get_num_algos_def(meta)
        # default_algo_kernel = make_default_algo_kernel(meta)
        # with args.out.with_suffix(".c").open("w") as fp:
        #     out = ""
        #     out += "#include <cuda.h>\n"
        #     out += "#include <stdint.h>\n"
        #     out += "#include <assert.h>\n"
        #     out += "\n"
        #     out += "\n".join(defs)
        #     out += "\n"
        #     out += func_pointers_def
        #     out += "\n"
        #     out += get_num_algos_def
        #     out += "\n"
        #     out += meta_const_def
        #     out += "\n"
        #     out += load_unload_def
        #     out += "\n"
        #     out += default_algo_kernel
        #     fp.write(out)


desc = """
Triton ahead-of-time linker:

This program takes in header files generated by compile.py, and generates a
single entry-point responsible for dispatching the user's input to the right
kernel given the specializations that were compiled.

Example usage:
python link.py /path/to/headers/*.h -o kernel_name
"""

# if __name__ == "__main__":
#     from argparse import ArgumentParser

#     parser = ArgumentParser(description=desc)
#     parser.add_argument(
#         "headers",
#         nargs="+",
#         help="Paths to header files to link. Must include linker directive annotations (autogenerated by ttc)",
#     )
#     parser.add_argument("--out", "-o", type=Path, help="Out filename")
#     parser.add_argument(
#         "--prefix",
#         type=str,
#         default="",
#         help="String to prefix kernel dispatcher names",
#     )
#     args = parser.parse_args()

#     # metadata
#     parser = HeaderParser()
#     includes = []
#     for header in args.headers:
#         h_path = Path(header)
#         h_str = h_path.read_text()
#         includes.append(h_path.name)
#         parser.extract_linker_meta(h_str)

#     # generate headers
#     algo_decls = [make_algo_decls(name, meta) for name, meta in parser.kernels.items()]
#     meta_lists = [meta for name, meta in parser.kernels.items()]
#     meta = meta_lists[0][0]
#     get_num_algos_decl = make_get_num_algos_decl(meta)
#     global_decl = make_global_decl(meta)
#     with args.out.with_suffix(".h").open("w") as fp:
#         out = "#include <cuda.h>\n"
#         out += "\n".join(algo_decls)
#         out += "\n"
#         out += get_num_algos_decl
#         out += "\n"
#         out += global_decl
#         fp.write(out)

#     # generate source
#     defs = [
#         make_kernel_hints_dispatcher(name, meta)
#         for name, meta in parser.kernels.items()
#     ]
#     names = [name for name in parser.kernels.keys()]
#     func_pointers_def = make_func_pointers(names, meta)
#     meta_const_def = make_kernel_meta_const_dispatcher(meta)
#     load_unload_def = make_kernel_load_def(names, meta)
#     get_num_algos_def = make_get_num_algos_def(meta)
#     default_algo_kernel = make_default_algo_kernel(meta)
#     with args.out.with_suffix(".c").open("w") as fp:
#         out = ""
#         out += "#include <cuda.h>\n"
#         out += "#include <stdint.h>\n"
#         out += "#include <assert.h>\n"
#         out += "\n"
#         out += "\n".join(defs)
#         out += "\n"
#         out += func_pointers_def
#         out += "\n"
#         out += get_num_algos_def
#         out += "\n"
#         out += meta_const_def
#         out += "\n"
#         out += load_unload_def
#         out += "\n"
#         out += default_algo_kernel
#         fp.write(out)
