from abc import ABC, abstractmethod
from pathlib import Path
from typing import Dict, List, Optional

from dataclasses import dataclass

from .. import DEFAULT_TRACE_DIR
from ..parsers import C_CUDA_HeaderParser, HeaderParser, KernelLinkerMeta
from .codegen import (
    C_CUDA_HeaderGenerator,
    C_CUDA_SourceGenerator,
    HeaderGenerator,
    SourceGenerator,
)


@dataclass
class AOTLinkerResult:
    header: str
    source: str
    header_path: str | Path
    source_path: str | Path


class AOTLinker(ABC):
    """Generates dispatcher code for compiled Triton kernels"""

    HEADER_PARSER_CLS: HeaderParser
    HEADER_GENERATOR_CLS: HeaderGenerator
    SOURCE_GENERATOR_CLS: SourceGenerator

    def __init__(
        self,
        kernel_name,
        headers: List[str],
        prefix: Optional[str] = "",
        trace_dir=None,
    ):
        """
        Args
            headers: Paths to header files to link. **Must** include linker directive annotations (autogenerated by ttc)

        """
        self.kernel_name = kernel_name
        self.headers = headers
        # self.out_path = out_path if isinstance(out_path, Path) else Path(out_path)
        self.prefix = prefix
        self.trace_dir = trace_dir or DEFAULT_TRACE_DIR
        # Parse headers for kernel linker metadata
        self.header_parser = self.HEADER_PARSER_CLS()
        kernels = self.header_parser.parse(self.headers)

        self.header_generator = self.HEADER_GENERATOR_CLS(kernels)
        self.source_generator = self.SOURCE_GENERATOR_CLS(kernels)

    def parse_headers(self):
        kernels = self.header_parser.parse(self.headers)

        return kernels

    def generate(self):
        header = self.header_generator.generate()
        source = self.source_generator.generate()
        header_path = self.trace_dir / f"{self.kernel_name}.h"
        source_path = self.trace_dir / f"{self.kernel_name}.c"
        with header_path.open("w") as fp:
            fp.write(header)
        with source_path.open("w") as fp:
            fp.write(source)

        return AOTLinkerResult(
            header=header,
            source=source,
            header_path=header_path,
            source_path=source_path,
        )


class AOT_C_CUDA_Linker(AOTLinker):
    """
    Generates C CUDA dispatcher code from compiled triton kernels
    """

    HEADER_PARSER_CLS = C_CUDA_HeaderParser
    HEADER_GENERATOR_CLS = C_CUDA_HeaderGenerator
    SOURCE_GENERATOR_CLS = C_CUDA_SourceGenerator


desc = """
Triton ahead-of-time linker:

This program takes in header files generated by compile.py, and generates a
single entry-point responsible for dispatching the user's input to the right
kernel given the specializations that were compiled.

Example usage:
python link.py /path/to/headers/*.h -o kernel_name
"""

# if __name__ == "__main__":
#     from argparse import ArgumentParser

#     parser = ArgumentParser(description=desc)
#     parser.add_argument(
#         "headers",
#         nargs="+",
#         help="Paths to header files to link. Must include linker directive annotations (autogenerated by ttc)",
#     )
#     parser.add_argument("--out", "-o", type=Path, help="Out filename")
#     parser.add_argument(
#         "--prefix",
#         type=str,
#         default="",
#         help="String to prefix kernel dispatcher names",
#     )
#     args = parser.parse_args()

#     # metadata
#     parser = HeaderParser()
#     includes = []
#     for header in args.headers:
#         h_path = Path(header)
#         h_str = h_path.read_text()
#         includes.append(h_path.name)
#         parser.extract_linker_meta(h_str)

#     # generate headers
#     algo_decls = [make_algo_decls(name, meta) for name, meta in parser.kernels.items()]
#     meta_lists = [meta for name, meta in parser.kernels.items()]
#     meta = meta_lists[0][0]
#     get_num_algos_decl = make_get_num_algos_decl(meta)
#     global_decl = make_global_decl(meta)
#     with args.out.with_suffix(".h").open("w") as fp:
#         out = "#include <cuda.h>\n"
#         out += "\n".join(algo_decls)
#         out += "\n"
#         out += get_num_algos_decl
#         out += "\n"
#         out += global_decl
#         fp.write(out)

#     # generate source
#     defs = [
#         make_kernel_hints_dispatcher(name, meta)
#         for name, meta in parser.kernels.items()
#     ]
#     names = [name for name in parser.kernels.keys()]
#     func_pointers_def = make_func_pointers(names, meta)
#     meta_const_def = make_kernel_meta_const_dispatcher(meta)
#     load_unload_def = make_kernel_load_def(names, meta)
#     get_num_algos_def = make_get_num_algos_def(meta)
#     default_algo_kernel = make_default_algo_kernel(meta)
#     with args.out.with_suffix(".c").open("w") as fp:
#         out = ""
#         out += "#include <cuda.h>\n"
#         out += "#include <stdint.h>\n"
#         out += "#include <assert.h>\n"
#         out += "\n"
#         out += "\n".join(defs)
#         out += "\n"
#         out += func_pointers_def
#         out += "\n"
#         out += get_num_algos_def
#         out += "\n"
#         out += meta_const_def
#         out += "\n"
#         out += load_unload_def
#         out += "\n"
#         out += default_algo_kernel
#         fp.write(out)
